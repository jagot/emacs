#+TITLE: Emacs configuration
#+AUTHOR: Stefanos Carlström
#+EMAIL: stefanos.carlstrom@gmail.com

#+PROPERTY: tangle yes
#+PROPERTY: comments org
* Introduction
** References
   - [[http://pages.sachachua.com/.emacs.d/Sacha.html][Sacha Chua's config]]
   - [[https://github.com/grettke/home][Grant Rettke's config]]
   - [[https://github.com/larstvei/dot-emacs][Lars Tveito's config]]

* Misc
  [[http://www.emacswiki.org/emacs/CommonLispForEmacs][Common Lisp macros for Emacs lisp]].
  #+BEGIN_SRC emacs-lisp
    (require 'cl-lib)

    (load "server")
    (unless (server-running-p) (server-start))
  #+END_SRC
** Startup
   #+BEGIN_SRC emacs-lisp
     (setq custom-file (expand-file-name "custom.el" user-emacs-directory))
     (load custom-file)
     (add-to-list 'load-path (expand-file-name "lisp" user-emacs-directory))

     (defvar osx?)
     (setq osx? (not (eq nil (memq window-system '(mac ns)))))
     (when osx?
       (progn
         (let ((default-directory "/usr/local/share/emacs/site-lisp/"))
           (normal-top-level-add-subdirs-to-load-path))
         (require 'osx-osascript)))
   #+END_SRC

** Packages
   [[https://github.com/cask/cask][Cask]] is used for external dependencies (see [[file:Cask][./Cask]]), [[https://github.com/jwiegley/use-package][use-package]]
   for lazy-loading of packages.
   #+BEGIN_SRC emacs-lisp
     (require 'cask "~/.cask/cask.el")
     (cask-initialize)
     (require 'use-package)
     (use-package pallet
       :init (pallet-mode))
   #+END_SRC
** Org tangle configuration
   Borrowed from [[https://github.com/larstvei/dot-emacs][Lars Tveito]].
   #+BEGIN_SRC emacs-lisp
     (use-package org
       :bind ("C-c e" . LaTeX-environment))
     (use-package ob-tangle
       :init
       (progn
         (setq init-file (concat user-emacs-directory "init.org"))
         (setq init-file-el (concat user-emacs-directory "init.el"))
         (setq init-file-bc (concat init-file-el "c"))
         (defun tangle-init ()
           "Tangle the code-blocks of this file, and subsequently
         byte-compile the result."
           (progn
             (org-babel-tangle-file init-file)
             (byte-compile-file init-file-el)))
         (add-hook 'after-save-hook (lambda ()
                                      (when (member (buffer-file-name)
                                                    (list (file-truename init-file)
                                                          (expand-file-name init-file)))
                                        (tangle-init))))
         (when (or
                (and
                 (file-exists-p init-file-bc)
                 (file-newer-than-file-p init-file init-file-bc))
                (not (file-exists-p init-file-bc)))
           (tangle-init))))
   #+END_SRC
** Encoding
   #+BEGIN_SRC emacs-lisp
     (setq locale-coding-system 'utf-8)
     (set-terminal-coding-system 'utf-8)
     (set-keyboard-coding-system 'utf-8)
     (set-selection-coding-system 'utf-8)
     (prefer-coding-system 'utf-8)
   #+END_SRC
** Text editing
   #+BEGIN_SRC emacs-lisp
     (add-hook 'text-mode-hook 'turn-on-auto-fill)
     (add-hook 'text-mode-hook 'flyspell-mode)
     (use-package rainbow-delimiters
       :init (add-hook 'prog-mode-hook 'rainbow-delimiters-mode))
   #+END_SRC
** Smartparens
   [[https://github.com/Fuco1/smartparens][smartparens]]
   #+BEGIN_SRC emacs-lisp
     (use-package smartparens
       :init
       (progn
         (smartparens-global-mode)
         (sp-local-pair 'hy-mode "'" nil :actions nil)
         (show-smartparens-global-mode t))
       :bind (("C-M-S-p" . sp-add-to-previous-sexp)
              ("C-M-S-n" . sp-add-to-next-sexp)))
     (use-package smartparens-config)
   #+END_SRC

** Spelling
   #+BEGIN_SRC emacs-lisp
     (setq-default ispell-program-name "aspell")
     (setq-default ispell-dictionary "en_GB-ize")
   #+END_SRC
** Ag
   #+BEGIN_SRC emacs-lisp
     (use-package ag
       :init (setq ag-highlight-search t))
   #+END_SRC
** Yasnippet
   Borrowed from [[http://www.emacswiki.org/emacs/Yasnippet#toc5][Emacs wiki]].
   #+BEGIN_SRC emacs-lisp
     (use-package yasnippet
       :init
       (progn
         (yas-global-mode 1)
         (defun yas-popup-isearch-prompt (prompt choices &optional display-fn)
           (when (featurep 'popup)
             (popup-menu*
              (mapcar
               (lambda (choice)
                 (popup-make-item
                  (or (and display-fn (funcall display-fn choice))
                      choice)
                  :value choice))
               choices)
              :prompt prompt
              ;; start isearch mode immediately
              :isearch t
              )))
         (setq yas-prompt-functions '(yas-popup-isearch-prompt yas-ido-prompt yas-no-prompt))))
   #+END_SRC

** Terminal
   Borrowed from [[http://www.emacswiki.org/emacs-ja/AnsiTermHints][Emacs wiki]].
   #+BEGIN_SRC emacs-lisp
     ;; Use this for remote so I can specify command line arguments
     (defun remote-term (new-buffer-name cmd &rest switches)
       (let ((term-ansi-buffer-name
              (apply 'make-term
                     (generate-new-buffer-name
                      (concat "*" new-buffer-name "*"))
                     cmd nil switches)))
       (set-buffer term-ansi-buffer-name)
       (term-mode)
       (term-char-mode)
       ;;(term-set-escape-char ?\C-x)
       (switch-to-buffer term-ansi-buffer-name)))


     ;; Kills buffer when terminal quits
     (defadvice term-sentinel (around my-advice-term-sentinel (proc
                                                               msg))
       (if (memq (process-status proc) '(signal exit))
           (let ((buffer (process-buffer proc)) )
             ad-do-it
             (kill-buffer buffer))
         ad-do-it))
     (ad-activate 'term-sentinel)

     (global-set-key (kbd "<f1>") (lambda ()
                                    (interactive)
                                    (eshell)))
     (global-set-key (kbd "S-<f1>") (lambda ()
                                      (interactive)
                                      (remote-term "lth" "ssh" "lth")))
     (global-set-key (kbd "M-<f1>") (lambda ()
                                      (interactive)
                                      (remote-term "home" "ssh" "home")))
     (add-hook 'term-mode-hook (lambda()
                                 (setq yas-dont-activate t)))

     (defun ag-eshell (string)
       "Search with ag using the current eshell directory and a given string.
        To be used from within an eshell alias
        (`alias ag 'ag-eshell $1'` within eshell)"
        (ag/search string (eshell/pwd)))
   #+END_SRC

*** External terminal
    This is used to open an external terminal emulator and run a
    command there.
    #+BEGIN_SRC emacs-lisp
      (defun ext-terminal (wd &rest args)
        (if osx?
            (osascript-run-str
             (concat
              "tell app \"Terminal\" to do script \""
              " cd " wd " && "
              (mapconcat 'identity args " ")
              " && exit\""))
          (if (executable-find "konsole")
              (apply #'call-process "konsole" nil 0 nil "--workdir" wd "-e" args)
            (apply #'call-process "xterm" nil 0 nil "-e" args))))
    #+END_SRC

** Web server
   #+BEGIN_SRC emacs-lisp
     (use-package web-server)
   #+END_SRC

** External programs
   #+BEGIN_SRC emacs-lisp
     (defvar opener)
     (setq opener "xdg-open")
     (when osx? (setq opener "open"))

     (defun open-in-external-app ()
       "Inspired by
     URL `http://ergoemacs.org/emacs/emacs_dired_open_file_in_ext_apps.html'"
       (interactive)
       (let ((file-list
              (if (string-equal major-mode "dired-mode")
                  (dired-get-marked-files)
                (list (buffer-file-name)))))
         (when (if (<= (length file-list) 5)
                   t
                 (y-or-n-p "Open more than 5 files? "))
           (mapc
            (lambda (file-path)
              (call-process opener nil 0 nil file-path))
            file-list))))
     (bind-key "C-M-o" 'open-in-external-app dired-mode-map)

     (eval-after-load "dired-aux"
       '(add-to-list 'dired-compress-file-suffixes
                     '("\\.zip\\'" ".zip" "unzip")))
   #+END_SRC

*** PATH variable
    #+BEGIN_SRC emacs-lisp
      (exec-path-from-shell-initialize)
    #+END_SRC

** Crontab
   #+BEGIN_SRC emacs-lisp
     (defun crontab-e ()
       (interactive)
       (with-editor-async-shell-command "crontab -e"))
   #+END_SRC

* Interface
** Misc
   #+BEGIN_SRC emacs-lisp
     (menu-bar-mode -1)
     (tool-bar-mode -1)
     (scroll-bar-mode -1)
     (setq inhibit-startup-screen 't)

     (setq auto-window-vscroll nil)

     (setq truncate-partial-width-windows nil)
     (mouse-wheel-mode t)
     (setq x-select-enable-clipboard t)
     (setq-default auto-revert-interval 1)
     (setq show-trailing-whitespace nil)
     (put 'narrow-to-region 'disabled nil)

     (setq-default indent-tabs-mode nil)

     (use-package tramp)

     (projectile-global-mode)

     (setq vc-follow-symlinks nil)
     (setq find-file-visit-truename t)

     (setq ring-bell-function #'ignore)

     ;; (setq auto-save-list-file-prefix (expand-file-name
     ;;                                   "tmp/auto-save-list/.saves-" emacs.d))

     (global-prettify-symbols-mode 1)
   #+END_SRC
** Mode line
   #+BEGIN_SRC emacs-lisp
     (use-package smart-mode-line
       :init (progn
               (sml/setup)
               (sml/apply-theme 'respectful)))
     (setq display-time-day-and-date 1)
     (setq display-time-24hr-format 1)
     (display-time-mode 1)
   #+END_SRC

** ido
   #+BEGIN_SRC emacs-lisp
     (use-package flx-ido
       :init
       (progn
         (ido-mode 1)
         (ido-everywhere 1)
         (flx-ido-mode 1)
         (setq ido-auto-merge-work-directories-length -1)
         ;; disable ido faces to see flx highlights.
         (setq ido-use-faces nil)))

     (use-package ido-vertical-mode
       :init
       (ido-vertical-mode 1))
   #+END_SRC
** Smex
   #+BEGIN_SRC emacs-lisp
     (use-package smex
       :config
       (smex-initialize)
       :bind
       (("M-x" . smex)
        ("S-M-x" . smex-major-mode-commands)))
   #+END_SRC

** Shortcut keys
   #+BEGIN_SRC emacs-lisp
     (use-package bind-key
       :init
       (progn
         (bind-key "C-?" 'help-command)
         (bind-key "M-?" 'mark-paragraph)
         (bind-key "C-h" 'delete-backward-char)
         (bind-key "M-h" 'backward-kill-word)
         (bind-key "C-j" 'newline)
         (bind-key "C-z" 'undo)

         (bind-key "C-x C-b" 'ibuffer)

         ;; (bind-key "M-q") '(lambda () (interactive (fill-paragraph 60)))

         (bind-key "M-S-<up>" 'enlarge-window)
         (bind-key "M-S-<down>" 'shrink-window)
         (bind-key "M-S-<right>" 'enlarge-window-horizontally)
         (bind-key "M-S-<left>" 'shrink-window-horizontally)

         (bind-key "C-c SPC w" 'whitespace-mode)
         (bind-key "C-c SPC c" 'whitespace-cleanup)

         (bind-key "C-c #" 'comment-region)

         (bind-key "C-x C-M-e" 'lisp-eval-region)

         (bind-key "<f7>" 'flyspell-buffer)
         (bind-key (kbd "<C-f7>") 'ispell-change-dictionary) ;; Does not work on MBP

         (bind-key "M-S-SPC" (lambda () (interactive) (insert " ")))))
   #+END_SRC
*** Super/subscripts
    #+BEGIN_SRC emacs-lisp
      (use-package iso-transl
        :config
        (iso-transl-define-keys
         `(("^0" . ,(vector (decode-char 'ucs #x2070)))
           ("^4" . ,(vector (decode-char 'ucs #x2074))) ; 1-3 already defined
           ("^5" . ,(vector (decode-char 'ucs #x2075)))
           ("^6" . ,(vector (decode-char 'ucs #x2076)))
           ("^7" . ,(vector (decode-char 'ucs #x2077)))
           ("^8" . ,(vector (decode-char 'ucs #x2078)))
           ("^9" . ,(vector (decode-char 'ucs #x2079)))
           ("^+" . ,(vector (decode-char 'ucs #x207A)))
           ("^-" . ,(vector (decode-char 'ucs #x207B)))
           ("^=" . ,(vector (decode-char 'ucs #x207C)))
           ("^(" . ,(vector (decode-char 'ucs #x207D)))
           ("^)" . ,(vector (decode-char 'ucs #x207E)))
           ("_0" . ,(vector (decode-char 'ucs #x2080)))
           ("_1" . ,(vector (decode-char 'ucs #x2081)))
           ("_2" . ,(vector (decode-char 'ucs #x2082)))
           ("_3" . ,(vector (decode-char 'ucs #x2083)))
           ("_4" . ,(vector (decode-char 'ucs #x2084)))
           ("_5" . ,(vector (decode-char 'ucs #x2085)))
           ("_6" . ,(vector (decode-char 'ucs #x2086)))
           ("_7" . ,(vector (decode-char 'ucs #x2087)))
           ("_8" . ,(vector (decode-char 'ucs #x2088)))
           ("_9" . ,(vector (decode-char 'ucs #x2089)))
           ("_+" . ,(vector (decode-char 'ucs #x208A)))
           ("_-" . ,(vector (decode-char 'ucs #x208B)))
           ("_=" . ,(vector (decode-char 'ucs #x208C)))
           ("_(" . ,(vector (decode-char 'ucs #x208D)))
           ("_)" . ,(vector (decode-char 'ucs #x208E))))))
    #+END_SRC
** Hydras
   Hydras taken from hydra-examples.el in the official distribution.
   #+BEGIN_SRC emacs-lisp
     (use-package hydra)

     (defun hydra-vi/pre ()
       (set-cursor-color "#e52b50"))

     (defun hydra-vi/post ()
       (set-cursor-color "#ffffff"))

     (bind-key
      "C-z"
      (defhydra hydra-vi (:pre hydra-vi/pre :post hydra-vi/post :color amaranth)
        "vi"
        ("l" forward-char)
        ("h" backward-char)
        ("j" next-line)
        ("k" previous-line)
        ("m" set-mark-command "mark")
        ("a" move-beginning-of-line "beg")
        ("e" move-end-of-line "end")
        ("d" delete-region "del" :color blue)
        ("y" kill-ring-save "yank" :color blue)
        ("q" nil "quit")))

     (bind-key
      "C-x SPC"
      (defhydra hydra-rectangle (:body-pre (rectangle-mark-mode 1)
                                           :color pink
                                           :post (deactivate-mark))
        "
       ^_k_^     _d_elete    _s_tring
     _h_   _l_   _o_k        _y_ank
       ^_j_^     _n_ew-copy  _r_eset
     ^^^^        _e_xchange  _u_ndo
     ^^^^        ^ ^         _p_aste
     "
        ("h" backward-char nil)
        ("l" forward-char nil)
        ("k" previous-line nil)
        ("j" next-line nil)
        ("e" hydra-ex-point-mark nil)
        ("n" copy-rectangle-as-kill nil)
        ("d" delete-rectangle nil)
        ("r" (if (region-active-p)
                 (deactivate-mark)
               (rectangle-mark-mode 1)) nil)
        ("y" yank-rectangle nil)
        ("u" undo nil)
        ("s" string-rectangle nil)
        ("p" kill-rectangle nil)
        ("o" nil nil)))

     (global-set-key
      (kbd "S-RET")
      (defhydra hydra-mc (:columns 3)
        "Multiple cursors"
        ("n" mc/mark-next-like-this "Mark next" :color red)
        ("p" mc/mark-previous-like-this "Mark previous" :color red)
        ("a" mc/mark-all-like-this "Mark all" :color blue)

        ("N" mc/skip-to-next-like-this "Skip next" :color red)
        ("P" mc/skip-to-previous-like-this "Skip previous" :color red)
        ("l" mc/edit-lines "Edit lines" :color blue)

        ("M-n" mc/unmark-next-like-this "Unmark next" :color red)
        ("M-p" mc/unmark-previous-like-this "Unmark previous" :color red)
        ("q" nil "quit" :color blue)))

     (defhydra hydra-projectile (:color blue
                                 :columns 4)
       "Projectile"
       ("a" projectile-ag "ag")
       ("b" projectile-switch-to-buffer "switch to buffer")
       ("c" projectile-invalidate-cache "cache clear")
       ("d" projectile-find-dir "dir")
       ("s-f" projectile-find-file "file")
       ("ff" projectile-find-file-dwim "file dwim")
       ("fd" projectile-find-file-in-directory "file curr dir")
       ("g" ggtags-update-tags "update gtags")
       ("i" projectile-ibuffer "Ibuffer")
       ("K" projectile-kill-buffers "Kill all buffers")
       ("o" projectile-multi-occur "multi-occur")
       ("p" projectile-switch-project "switch")
       ("r" projectile-recentf "recent file")
       ("x" projectile-remove-known-project "remove known")
       ("X" projectile-cleanup-known-projects "cleanup non-existing")
       ("z" projectile-cache-current-file "cache current")
       ("q" nil "cancel"))
     (bind-key "C-S-p" 'hydra-projectile/body)
   #+END_SRC
** Modalka
   #+BEGIN_SRC emacs-lisp
     (use-package modalka
       :init
       (progn
         (add-hook 'text-mode-hook #'modalka-mode)
         (add-hook 'prog-mode-hook #'modalka-mode)
         (setq-default cursor-type 'box)
         (setq modalka-cursor-type 'hollow)
         (let ((pairs '(("W" . "M-w")
                        ("Y" . "M-y")
                        ("a" . "C-a")
                        ("b" . "C-b")
                        ("k" . "C-M-b")
                        ("e" . "C-e")
                        ("f" . "C-f")
                        ("j" . "C-M-f")
                        ("g" . "C-g")
                        ("n" . "C-n")
                        ("p" . "C-p")
                        ("v" . "C-v")
                        ("V" . "M-v")
                        ("w" . "C-w")
                        ("y" . "C-y")
                        ("SPC" . "C-SPC")
                        ("M-e" . "C-x C-e")
                        ("#" . "C-c #"))))
           (dolist (pair pairs)
             (modalka-define-kbd (car pair) (cdr pair)))))
       :bind (("<return>" . modalka-mode)))
   #+END_SRC

** OS X-specific configuration
   #+BEGIN_SRC emacs-lisp
     (when osx?
       (progn
         (setq mac-option-modifier nil
               mac-command-modifier 'meta
               x-select-enable-clipboard t
               ns-use-native-fullscreen nil
               alert-default-style 'growl
               insert-directory-program "gls")
         (menu-bar-mode 1)
         (setq-default org-babel-python-command "python3")
         (setenv "LC_ALL" "en_US.UTF-8")
         (setenv "LC_CTYPE" "en_US.UTF-8")
         (setenv "LANG" "en_US.UTF-8")))
   #+END_SRC
** Linum mode
   #+BEGIN_SRC emacs-lisp
     (use-package linum
       :init
       (progn
         (defcustom linum-disabled-modes-list
           '(eshell-mode wl-summary-mode compilation-mode org-mode
                         image-mode dired-mode doc-view-mode)
           "* List of modes disabled when global linum mode is on"
           :type '(repeat (sexp :tag "Major mode"))
           :tag " Major modes where linum is disabled: "
           :group 'linum
           )
         (defcustom linum-disable-starred-buffers 't
           "* Disable buffers that have stars in them like *Gnu Emacs*"
           :type 'boolean
           :group 'linum)

         (defun linum-on ()
           "* When linum is running globally, disable line number in
     modes defined in `linum-disabled-modes-list'. Changed by
     linum-off. Also turns off numbering in starred modes like *scratch*"
           (unless (or (minibufferp) (member major-mode linum-disabled-modes-list)
                       (and linum-disable-starred-buffers (string-match "*" (buffer-name))))
             (linum-mode 1)))
         (setq linum-format "%3d ")
         (global-linum-mode)))
   #+END_SRC
** Theme
   #+BEGIN_SRC emacs-lisp
     (defvar emacs-theme)
     (setq emacs-theme 'zenburn)
     (load-theme emacs-theme t)
   #+END_SRC
*** Fonts
     #+BEGIN_SRC emacs-lisp
       (set-default-font "Consolas-13")
       (set-fontset-font t 'greek "Consolas")
       (set-fontset-font t 'cyrillic "Consolas")
       ;; (set-fontset-font t (cons #x2070 #x209F) "Consolas")
       (set-fontset-font t 'hangul
                         (font-spec :family "Nanum Gothic"))
       (set-fontset-font t 'japanese-jisx0208
                         (font-spec :family "Kozuka Gothic Pr6N"))
     #+END_SRC
*** Highlight current line
    #+BEGIN_SRC emacs-lisp
      (global-hl-line-mode 1)
      (defvar hl-dark-colour)
      (defvar hl-light-colour)
      (setq hl-dark-colour "#4F4F4F")
      (setq hl-light-colour "#CDD9FF")
      ;; (set-face-background 'hl-line hl-dark-colour)
    #+END_SRC
*** Darkroom
    Function to quickly toggle between dark/light themes, useful in
    conjunction with f-lux' darkroom mode.
    #+BEGIN_SRC emacs-lisp
      (defvar in-darkroom)
      (setq in-darkroom nil)

      (defun toggle-darkroom ()
        "Enable f-lux' darkroom-friendly colours."
        (interactive)
        (if (not in-darkroom)
          (progn
            (disable-theme emacs-theme)
            (set-face-background 'hl-line hl-light-colour)
            (setq in-darkroom 't))
          (progn
            (enable-theme emacs-theme)
            (set-face-background 'hl-line hl-dark-colour)
            (setq in-darkroom nil))))
      (bind-key "C-c d" 'toggle-darkroom)
    #+END_SRC
** Multiple cursors
   #+BEGIN_SRC emacs-lisp
     (use-package multiple-cursors
       :bind (("C-S-c C-S-c" . mc/edit-lines)
              ("C->" . mc/mark-next-like-this)
              ("C-<" . mc/mark-previous-like-this)
              ("C-c C-<" . mc/mark-all-like-this)))
   #+END_SRC
** Magit

   #+BEGIN_SRC emacs-lisp
     (use-package magit
       :bind (("C-c m" . magit-status))
       :init
       (progn
         (setq magit-last-seen-setup-instructions "1.4.0")))

     (use-package magit-gitflow
       :init
       (add-hook 'magit-mode-hook 'turn-on-magit-gitflow))
   #+END_SRC
** Ace-window
   #+BEGIN_SRC emacs-lisp
     (use-package ace-window
       :init (setq aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l))
       :bind (("C-x o" . ace-window)))
   #+END_SRC
** Swiper
   #+BEGIN_SRC emacs-lisp
     (use-package swiper
       :init (progn
               (ivy-mode 1)
               (setq ivy-use-virtual-buffers t))
       :bind (("C-s" . swiper)
              ("C-r" . swiper)))
   #+END_SRC

** Peep-dired
   #+BEGIN_SRC emacs-lisp
     (use-package peep-dired
       :defer t
       :bind (:map dired-mode-map
                   ("P" . peep-dired)))
   #+END_SRC

* Helm
  #+BEGIN_SRC emacs-lisp
    (use-package helm-config
      :bind ("C-c h" . helm-mini))
    (use-package helm-ag
      :bind ("C-c a" . helm-do-ag))
  #+END_SRC

* Programming
** Company
   #+BEGIN_SRC emacs-lisp
     (use-package company-math)
     (use-package company
       :config (progn
                 (setq company-tooltip-limit 20)
                 (setq company-idle-delay 0.5)
                 (setq company-show-numbers t)

                 (add-to-list 'company-backends #'company-math-symbols-unicode)

                 (global-company-mode 1))
       :bind (("<C-tab>" . company-complete)))
     (use-package helm-company
       :bind (("C-:" . helm-company)))
     (use-package company-quickhelp
       :init (company-quickhelp-mode 1))
   #+END_SRC
** Flycheck
   [[https://github.com/flycheck/flycheck][Flycheck]]
   #+BEGIN_SRC emacs-lisp
     (use-package flycheck
       :init
       (progn
         (add-hook 'after-init-hook #'global-flycheck-mode)
         (setq-default flycheck-disabled-checkers '(emacs-lisp-checkdoc))
         (add-hook 'c++-mode-hook (lambda () (setq flycheck-clang-language-standard "c++11")))))
   #+END_SRC

** C/C++
   [[https://github.com/rocky/emacs-dbgr][emacs-dbgr]]
   #+BEGIN_SRC emacs-lisp
     (add-to-list 'auto-mode-alist '("\\.h\\'" . c++-mode))
     (add-hook 'c-mode-common-hook
               (lambda ()
                 (bind-key "C-c c" 'compile)
                 (setq prettify-symbols-alist
                       '(("!=" . ?≠)
                         ("<=" . ?≤)
                         (">=" . ?≥)
                         ("&&" . ?∧)
                         ("||" . ?∨)
                         ("M_PI" . ?π)))))
     (defun start-debugger ()
       (interactive)
       (if (null cppcm-src-dir)
           (realgud:gdb)
         (realgud:gdb
          (let ((exe-path (cppcm-get-exe-path-current-buffer)))
            (concat "gdb --fullname " exe-path)))))
     (use-package realgud
       :bind (("C-c g" . start-debugger)))
   #+END_SRC

*** Cmake
    [[https://github.com/redguardtoo/cpputils-cmake][cpputils-cmake]]
    #+BEGIN_SRC emacs-lisp
      (use-package cpputils-cmake
        :init
        (progn
          (add-hook 'c-mode-common-hook
                    (lambda ()
                      (if (derived-mode-p 'c-mode 'c++-mode)
                          (cppcm-reload-all))))
          (setq cppcm-write-flymake-makefile nil)))
    #+END_SRC

*** Header guards
    #+BEGIN_SRC emacs-lisp
      (defun traverse-project (dir file)
        "Return the path of the current file relative to the project root."
        (let ((stop-dirs
               (list (expand-file-name "~") ; Stop at $HOME
                     "/tmp"
                     "/"
                     (expand-file-name (concat dir "/../src")) ; Stop if current directory is named src
                     (expand-file-name (concat dir "/../libs")) ; or libs
                     (expand-file-name (concat dir "/../include")))) ; or include
              (ndir (directory-file-name (expand-file-name dir))))
          (let ((relname (file-relative-name file ndir)))
            (if (cl-find ndir stop-dirs :test #'equal)
                relname
              (if (file-accessible-directory-p (expand-file-name (concat ndir "/.git"))) ; If there is a .git directory, stop
                  relname
                (traverse-project (concat ndir "/..") file))))))

      (defun get-header-guard ()
        "Return the header guard symbol to be used for the current file."
        (let* ((file (buffer-file-name))
               (path (traverse-project (file-name-directory file) file)))
          (upcase (cl-substitute
                   ?_ ?. (cl-substitute
                          ?_ ?/ (if (string= (substring path 0 1) "/")
                                    (substring path 1)
                                  path))))))

      (defun insert-header-guard ()
        (interactive)
        (let ((l (length (buffer-name))))
          (when (or (equal (substring (buffer-name) (- l 2)  l) ".h")
                    (equal (substring (buffer-name) (- l 4)  l) ".cuh"))
            (when (not (file-exists-p (buffer-file-name)))
              (let ((header-guard (get-header-guard)))
                (insert (concat "//  @ Project : " (projectile-project-name)))
                (newline)
                (insert (concat "//  @ File Name : " (buffer-name)))
                (newline)
                (insert (concat "//  @ Date : " (format-time-string "%Y-%m-%d")))
                (newline)
                (insert (concat "//  @ Author : Stefanos Carlström"))
                (newline)
                (insert "//")
                (newline)
                (insert "//")
                (newline)
                (insert (concat "#ifndef " header-guard))
                (newline)
                (newline)
                (insert (concat "#define " header-guard))
                (newline)(newline)
                (newline)(newline)
                (insert (concat "#endif //" header-guard))
                (forward-line -2))))))

      (add-hook 'c-mode-common-hook 'insert-header-guard)
    #+END_SRC

*** Cuda
    #+BEGIN_SRC emacs-lisp
      (use-package cuda-mode
        :mode (("\\.cu\\'" . cuda-mode)
               ("\\.cuh\\'" . cuda-mode)))
    #+END_SRC

** ESS
   #+BEGIN_SRC emacs-lisp
     (use-package ess-site)
   #+END_SRC

** Julia
   #+BEGIN_SRC emacs-lisp
     (use-package julia-mode
       :init (add-hook 'julia-mode-hook
                       (lambda ()
                         (setq prettify-symbols-alist
                               '(("!=" . ?≠)
                                 ("<=" . ?≤)
                                 (">=" . ?≥)
                                 ("&&" . ?∧)
                                 ("||" . ?∨)
                                 ("->" . ?↦))))))
   #+END_SRC

** Lisps
   #+BEGIN_SRC emacs-lisp
     (add-to-list 'auto-mode-alist '("\\.al\\'" . lisp-mode))
     (add-hook 'inferior-lisp-mode-hook (lambda () (rainbow-delimiters-mode 0)))
     (add-hook 'lisp-mode-common-hook
               (lambda ()
                 (setq prettify-symbols-alist
                       '(("lambda" . ?λ)
                         ("<=" . ?≤)
                         (">=" . ?≥)))))
   #+END_SRC
*** Clojure
    #+BEGIN_SRC emacs-lisp
      (use-package clojure-mode
        :mode "\\.clj\\'"
        :config (use-package cider
                :init
                (add-hook 'cider-mode-hook 'cider-turn-on-eldoc-mode)))
    #+END_SRC

*** Hy
    #+BEGIN_SRC emacs-lisp
      (use-package hy-mode
        :mode "\\.hy\\'"
        :config
        (add-hook 'hy-mode-hook
                  (lambda () (bind-key "C-c M-j" 'inferior-lisp))))
    #+END_SRC

** Hex colors
   Borrowed from [[http://www.emacswiki.org/emacs/HexColour][Emacs wiki]].
   #+BEGIN_SRC emacs-lisp
     (defun hexcolour-luminance (color)
       "Calculate the luminance of a color string (e.g. \"#ffaa00\", \"blue\").
       This is 0.3 red + 0.59 green + 0.11 blue and always between 0 and 255."
       (let* ((values (x-color-values color))
              (r (car values))
              (g (cadr values))
              (b (caddr values)))
         (floor (+ (* .3 r) (* .59 g) (* .11 b)) 256)))
     (defun hexcolour-add-to-font-lock ()
       (interactive)
       (font-lock-add-keywords
        nil
        `((,(concat "#[0-9a-fA-F]\\{3\\}[0-9a-fA-F]\\{3\\}?\\|"
                    (regexp-opt (x-defined-colors) 'words))
           (0 (let ((colour (match-string-no-properties 0)))
                (put-text-property
                 (match-beginning 0) (match-end 0)
                 'face `((:foreground ,(if (> 128.0 (hexcolour-luminance colour))
                                           "white" "black"))
                         (:background ,colour)))))))))

     (add-hook 'css-mode-hook 'hexcolour-add-to-font-lock)
     (add-hook 'org-mode-hook 'hexcolour-add-to-font-lock)
     (add-hook 'emacs-lisp-mode-hook 'hexcolour-add-to-font-lock)
   #+END_SRC

** Python
   #+BEGIN_SRC emacs-lisp
     (setq python-shell-interpreter "ipython")
   #+END_SRC

** Ruby
   #+BEGIN_SRC emacs-lisp
     (use-package ruby-mode
       :mode "\\.rb\\'"
       :config (progn
               (use-package inf-ruby
                 :init (inf-ruby-minor-mode)
                 (rvm-use-default))))
   #+END_SRC

** Web development
*** Web mode
    #+BEGIN_SRC emacs-lisp
      (use-package web-mode
        :mode "\\.erb\\'"
        :config
        (add-hook 'web-mode-hook 'turn-off-smartparens-mode))
    #+END_SRC
* Modes
  Misc modes
  #+BEGIN_SRC emacs-lisp
    (use-package matlab-mode
      :mode (("\\.m\\'" . matlab-mode)))

    (autoload 'gedcom-mode "gedcom")
    (setq auto-mode-alist (cons '("\\.ged$" . gedcom-mode) auto-mode-alist))
  #+END_SRC

** Cmake
   #+BEGIN_SRC emacs-lisp
     (use-package cmake-mode
       :mode (("CMakeLists\\.txt\\'" . cmake-mode)
              ("\\.cmake\\'" . cmake-mode))
       :config
       (progn
         (defun cmake-rename-buffer ()
           "Renames a CMakeLists.txt buffer to cmake-<directory name>."
           (interactive)
           (when (and (buffer-file-name) (string-match "CMakeLists.txt" (buffer-name)))
             (let ((new-buffer-name (concat "cmake-"
                                            (file-name-nondirectory
                                             (directory-file-name
                                              (file-name-directory (buffer-file-name)))))))
               (rename-buffer new-buffer-name t))))

         (add-hook 'cmake-mode-hook (function cmake-rename-buffer))

         (add-hook 'cmake-mode-hook
                   '(lambda()
                      (local-set-key (kbd "C-c q") 'cmake-quick-document)
                      (defun cmake-quick-document()
                        (interactive)
                        (beginning-of-line)
                        (insert (concat "project(" (read-string "Project name: ") ")\n"))
                        (insert (concat "cmake_minimum_required(VERSION " (read-string "CMake version: " "2.8") ")\n\n"))
                        (when (yes-or-no-p "C++ warnings and optimization flags? ")
                          (insert "set(CMAKE_CXX_FLAGS \"--std=c++11 -Wall -Wextra\")\n")
                          (insert "if(\"${CMAKE_BUILD_TYPE}\" STREQUAL \"Release\")\n")
                          (insert "  set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -O3\")\n")
                          (insert "else()\n")
                          (insert "  set(CMAKE_BUILD_TYPE \"Debug\")\n")
                          (insert "  set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -O0 -g\")\n")
                          (insert "  add_definitions(\"-DDEBUG\")\n")
                          (insert "endif()\n\n")))))))
   #+END_SRC
** LaTeX
   #+BEGIN_SRC emacs-lisp
     (use-package tex-site
       :defer t)

     (defun latex-start-latexmk (arg)
       (interactive "p")
       (let* ((latexcmd (s-match "LATEX_CMD: \\([a-z]+\\)latex" (buffer-string)))
              (pdflatex
               (concat "-pdflatex='"
                       (if latexcmd (concat (second latexcmd) "latex")
                         "xelatex")
                      "'")))
         (if (= arg 4)
             (ext-terminal default-directory
                           "latexmk" "-C"
                           pdflatex
                           (concat (file-name-sans-extension buffer-file-name) ".tex")))
         (ext-terminal default-directory
                       "latexmk" "-shell-escape" "-pvc"
                       pdflatex
                       (concat (file-name-sans-extension buffer-file-name) ".tex"))))

     (add-hook 'LaTeX-mode-hook
               (lambda ()
                 (bind-key "C-c c" 'latex-start-latexmk LaTeX-mode-map)))
   #+END_SRC
** Ediff
   #+BEGIN_SRC emacs-lisp
     (setq-default ediff-split-window-function 'split-window-horizontally)
     (setq-default ediff-window-setup-function 'ediff-setup-windows-plain)

     ;; Borrowed from http://stackoverflow.com/a/18122275/1079038
     (defvar ediff-dired-file-1)

     (defun ediff-push ()
       (interactive)
       (setq ediff-dired-file-1 (dired-get-filename)))
     (defun ediff-pop ()
       (interactive)
       (ediff-files ediff-dired-file-1 (dired-get-filename)))
     (add-hook 'dired-mode-hook
           (lambda()
                 (define-key dired-mode-map (kbd "C-c u") 'ediff-push)
                 (define-key dired-mode-map (kbd "C-c o") 'ediff-pop)))
   #+END_SRC
** Lilypond
   #+BEGIN_SRC emacs-lisp
     ;; (use-package lilypond-mode
     ;;   :mode ("\\.ly\\'" . LilyPond-mode))
   #+END_SRC
*** Lyqi
    #+BEGIN_SRC emacs-lisp
      (add-to-list 'load-path (expand-file-name "lyqi" user-emacs-directory))
      (use-package lyqi
        :mode (("\\.ly$" . lyqi-mode)
               ("\\.ily$" . lyqi-mode))
        :init
        (progn
          (setq
           lyqi:prefered-languages '(english)
           lyqi:midi-command "timidity")
          (bind-key "C-c c" (lambda ()
                              (interactive)
                              (save-buffer)
                              (lyqi:compile-ly))))
          :bind (("C-c C-m" . lyqi:open-midi)))
    #+END_SRC
** PKGBUILD
   #+BEGIN_SRC emacs-lisp
     (use-package pkgbuild-mode
       :mode "/PKGBUILD$")
   #+END_SRC

* Org
** Org configuration
   #+BEGIN_SRC emacs-lisp
     (setq org-hide-leading-stars 't)
     (setq org-src-fontify-natively 't)

     (use-package org-mouse)
     (use-package ox-beamer)
   #+END_SRC
** Org functions
   Borrowed from [[http://wenshanren.org/?p=334][Ren Wenshan]].
   #+BEGIN_SRC emacs-lisp
     (defun org-insert-src-block (src-code-type)
       "Insert a `SRC-CODE-TYPE' type source code block in org-mode."
       (interactive
        (let ((src-code-types
               '("emacs-lisp" "python" "julia" "C" "sh" "java" "js" "clojure" "C++" "css"
                 "calc" "asymptote" "dot" "gnuplot" "ledger" "lilypond" "mscgen"
                 "octave" "oz" "plantuml" "R" "sass" "screen" "sql" "awk" "ditaa"
                 "haskell" "latex" "lisp" "matlab" "ocaml" "org" "perl" "ruby"
                 "scheme" "sqlite")))
          (list (ido-completing-read "Source code type: " src-code-types))))
       (progn
         (newline-and-indent)
         (insert (format "#+BEGIN_SRC %s\n" src-code-type))
         (newline-and-indent)
         (insert "#+END_SRC\n")
         (forward-line -2)
         (org-edit-src-code)))
     (bind-key "C-c s" 'org-insert-src-block org-mode-map)
   #+END_SRC
** Org Babel
   #+BEGIN_SRC emacs-lisp
     (org-babel-do-load-languages
      'org-babel-load-languages
      '((python . t)
        (emacs-lisp . t)
        (julia . t)
        (C . t)
        (sh . t)
        (ruby . t)
        (clojure . t)
        (octave . t)))
     (setq org-confirm-babel-evaluate nil)
     (use-package ob-clojure
       :defer t
       :config (setq org-babel-clojure-backend 'cider))
   #+END_SRC
** Org LaTeX export
   #+BEGIN_SRC emacs-lisp
     (use-package ox-latex)
     (setq org-latex-listings t)

     ;; Default packages included in every tex file, pdflatex, xelatex or lualatex
     (setq org-export-latex-packages-alist
           '(("" "graphicx" t)
             ("" "longtable" nil)
             ("" "float" nil)))

     ;; Originally taken from Bruno Tavernier: http://thread.gmane.org/gmane.emacs.orgmode/31150/focus=31432
     ;; but adapted to use latexmk 4.20 or higher.
     (defun my-auto-tex-cmd (backend)
       "When exporting from .org with latex, automatically run latex,
     pdflatex, or xelatex as appropriate, using latexmk."
       (let ((texcmd)))
       ;; default command: pdflatex
       (setq texcmd "latexmk -pdflatex='pdflatex -shell-escape' -pdf %f")
       ;; oldstyle latex via dvi
       (if (string-match "LATEX_CMD: dvilatex" (buffer-string))
           (setq texcmd "latexmk -dvi -pdfps %f"))
       ;; xelatex -> .pdf
       (if (string-match "LATEX_CMD: xelatex" (buffer-string))
           (setq texcmd "latexmk -pdflatex='xelatex -shell-escape' -pdf %f"))
       ;; lualatex -> .pdf
       (if (string-match "LATEX_CMD: lualatex" (buffer-string))
           (setq texcmd "latexmk -pdflatex='lualatex -shell-escape' -pdf %f"))
       ;; LaTeX compilation command
       (setq org-latex-pdf-process (list texcmd))

       ;; default packages for ordinary latex or pdflatex export
       (setq org-latex-default-packages-alist
             '(("AUTO" "inputenc" t)
               ("T1" "fontenc" t)
               ("" "fixltx2e" nil)
               ("" "wrapfig" nil)
               ("" "soul" t)
               ("" "hyperref" nil)))

       ;; Packages to include when xelatex is used
       ;; (see https://github.com/kjhealy/latex-custom-kjh for the
       ;; non-standard ones.)
       (if (string-match "LATEX_CMD: xelatex" (buffer-string))
           (setq org-latex-default-packages-alist
                 '(("" "url" t)
                   ("" "rotating" t)
                   ("babel" "csquotes" t)
                   ("" "listings" nil)
                   ("" "soul" t))))
       (unless (string-match "startup: beamer" (buffer-string))
         (setq org-latex-default-packages-alist
               (append '(("svgnames" "xcolor" t)
                         ("colorlinks=true, linkcolor=FireBrick, urlcolor=FireBrick, citecolor=ForestGreen, plainpages=false, pdfpagelabels, bookmarksnumbered" "hyperref" nil))
                       org-latex-default-packages-alist)))
       (if (string-match "LATEX_CMD: lualatex" (buffer-string))
           (setq org-latex-default-packages-alist
                 '(("" "url" t)
                   ("" "rotating" t)
                   ("babel" "csquotes" t)
                   ("" "listings" nil)
                   ("svgnames" "xcolor" t)
                   ("" "soul" t)
                   ("colorlinks=false, linkcolor=FireBrick, urlcolor=FireBrick, citecolor=ForestGreen, plainpages=false, pdfpagelabels, bookmarksnumbered" "hyperref" nil)))))
     (add-hook 'org-export-before-processing-hook 'my-auto-tex-cmd)

     (use-package ox-bibtex)
     (use-package ox-md)

     (bind-key "C-c c" 'latex-start-latexmk org-mode-map)
   #+END_SRC
** Out{org/shine}

   #+BEGIN_SRC emacs-lisp
     (defvar outline-minor-mode-prefix "\M-#")
     (use-package outshine
       :init
       (progn
         (add-hook 'outline-minor-mode-hook 'outshine-hook-function)
         (add-hook 'c-mode-common-hook 'outline-minor-mode)))
   #+END_SRC
** Org preview LaTeX
   #+BEGIN_SRC emacs-lisp
     (bind-key "C-x p" 'org-toggle-latex-fragment)
     (add-hook 'c-mode-common-hook
               (lambda () (org-toggle-latex-fragment '(16))))
   #+END_SRC
** Org download
   #+BEGIN_SRC emacs-lisp
     (use-package org-download)
   #+END_SRC

* BibTeX
  #+BEGIN_SRC emacs-lisp
    (setq bibtex-autokey-name-case-convert-function 'capitalize
          bibtex-autokey-year-length 4
          bibtex-autokey-year-title-separator ""
          bibtex-autokey-titleword-length 5
          bibtex-autokey-titleword-separator "")
    (setq bibliography-directory (expand-file-name "~/references"))
    (setq bibliography-file (concat bibliography-directory "/references.bib"))
  #+END_SRC

** Ebib
   #+BEGIN_SRC emacs-lisp
     (use-package ebib
       :bind ("C-c e" . ebib)
       :config (progn
                 (setq ebib-preload-bib-files '(bibliography-file))
                 (org-add-link-type "ebib" 'ebib-open-org-link)))
   #+END_SRC
** Helm Bibtex
  #+BEGIN_SRC emacs-lisp
    (use-package helm-bibtex
      :config (progn
              (defun my-helm-bibtex-format-citation-cite (keys)
                (s-join ", "
                        (--map (format "cite:%s" it) keys)))
              (add-to-list 'helm-bibtex-format-citation-functions
                           '(org-mode . my-helm-bibtex-format-citation-cite)))
      :bind ("C-c b" . helm-bibtex))
    (setq helm-bibtex-bibliography bibliography-file)
    (setq helm-bibtex-library-path bibliography-directory)
    (setq helm-bibtex-pdf-symbol "P")
    (setq helm-bibtex-pdf-open-function
          (lambda (fpath) (shell-command-to-string
                           (concat opener " " fpath " &"))))
  #+END_SRC
** Doi2Bibtex
   Borrowed from [[http://blog.anghyflawn.net/2014/04/22/emacs-give-a-doi-get-a-bibtex-entry/][Pavel Iosad]]. Should maybe implement something like
   [[https://gist.github.com/mardukbp/6576418][this]] instead.
   #+BEGIN_SRC emacs-lisp
     (defun get-bibtex-from-doi (doi)
       "Get a BibTeX entry from the DOI"
       (interactive "MDOI: ")
       (let ((url-mime-accept-string "text/bibliography;style=bibtex"))
         (with-current-buffer
             (url-retrieve-synchronously
              (format "http://dx.doi.org/%s"
                      (replace-regexp-in-string "http://dx.doi.org/" "" doi)))
           (switch-to-buffer (current-buffer))
           (goto-char (point-max))
           (setq bibtex-entry
                 (buffer-substring
                  (string-match "@" (buffer-string))
                  (point)))
           (kill-buffer (current-buffer))))
       (insert (decode-coding-string bibtex-entry 'utf-8))
       (bibtex-fill-entry))
   #+END_SRC

* Mail
  #+BEGIN_SRC emacs-lisp
    (use-package mu4e
      :config
      (progn
        (setq
         mu4e-maildir       "~/Maildir"   ;; top-level Maildir
         mu4e-split-view 'vertical
         mu4e-headers-visible-columns 90
         mu4e-use-fancy-chars t
         mu4e-view-show-images t
         mu4e-view-prefer-html t
         mu4e-get-mail-command "mbsync -a"
         mu4e-compose-signature-auto-include nil
         mu4e-compose-signature "")
        (mu4e-maildirs-extension)
        (add-hook 'mu4e-view-mode-hook 'visual-line-mode)
        (add-to-list 'mu4e-view-actions
                     '("ViewInBrowser" . mu4e-action-view-in-browser) t)
        (when (fboundp 'imagemagick-register-types)
          (imagemagick-register-types))
        (use-package mu4e-contrib
          :config
          (setq mu4e-html2text-command 'mu4e-shr2text)))
      :bind (("C-x m" . mu4e)))
  #+END_SRC
* Calendar
  #+BEGIN_SRC emacs-lisp
    (use-package calfw
      :config
      (progn
        (use-package calfw-ical)
        (use-package calfw-org)
        (setq cfw:fchar-junction ?╬
              cfw:fchar-vertical-line ?║
              cfw:fchar-horizontal-line ?═
              cfw:fchar-left-junction ?╠
              cfw:fchar-right-junction ?╣
              cfw:fchar-top-junction ?╦
              cfw:fchar-top-left-corner ?╔
              cfw:fchar-top-right-corner ?╗)
        (setq calendar-week-start-day 1)
        (setq calendar-sources (list
                                (cfw:org-create-source "Blue")))
        (let ((calendar-file (concat user-emacs-directory "calfw-conf.el")))
          (if (f-exists? calendar-file)
              (load calendar-file)))
        (defun my-open-calendar ()
          (interactive)
          (cfw:open-calendar-buffer
           :contents-sources calendar-sources)))
      :bind (("C-x q" . my-open-calendar)))
  #+END_SRC
